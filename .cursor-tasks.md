# Long Video Render - Cursor AI Context

## Project Overview

This is a **high-performance video rendering system** that processes video jobs from a Supabase database. The system downloads video and audio files, loops them to specified durations, and merges them using FFmpeg with optimizations for speed and 4K content.

## Core Architecture

- **Database**: Supabase PostgreSQL with `dark_channel_soundtrack_videos` table
- **Language**: Node.js with ES Modules (ESM)
- **Video Processing**: FFmpeg with fluent-ffmpeg wrapper
- **Job Queue**: Supabase-based job claiming with race condition prevention
- **Storage**: Local temp files with automatic cleanup

## Key Design Principles

1. **Ultra-fast Processing**: Parallel video/audio operations, optimized FFmpeg settings
2. **4K Ready**: High-resolution video support with proper encoding
3. **Race Condition Safe**: Atomic job claiming prevents multiple workers processing same job
4. **Auto-cleanup**: Temporary files automatically removed after processing
5. **Error Recovery**: Comprehensive error handling with job status tracking



## File Structure

```
src/
├── index.js          # Main worker orchestration
├── supabase.js       # Database job management  
├── downloader.js     # Media file downloading
├── mediaProcessor.js # FFmpeg video/audio processing
└── logger.js         # Structured logging

package.json          # Dependencies and scripts
.env                  # Environment configuration
README.md            # Documentation
```

## Job Processing Flow

1. **Job Discovery**: Query `dark_channel_soundtrack_videos` WHERE `status = 'waiting_render'`
2. **Atomic Claiming**: Update status to `'rendering'` with race condition protection
3. **Parallel Download**: Download `input_video_url` and `soundtrack_url` simultaneously  
4. **Parallel Processing**: Loop video and audio to `length_minutes` duration in parallel
5. **Merge**: Combine looped video+audio with optimized FFmpeg settings
6. **Complete**: Update `final_video_url` and status to `'completed'`
7. **Cleanup**: Remove temporary files

## FFmpeg Optimizations

- **Ultra-fast preset** for maximum speed
- **Stream copying** to avoid re-encoding when possible
- **Parallel processing** for video and audio operations
- **Smart looping** using `stream_loop` for efficiency
- **4K settings**: Proper encoding for high-resolution content
- **Hardware acceleration** where available

## Common Tasks & Commands

### Development
```bash
npm run dev          # Development mode with auto-restart
npm start            # Production mode
```

### Environment Variables
```env
SUPABASE_URL=https://htermunpfoqhsbpolnym.supabase.co
SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
JOB_CHECK_INTERVAL=5000    # Milliseconds between job checks
TEMP_DIR=./temp            # Temporary file storage
OUTPUT_DIR=./output        # Final output location
LOG_LEVEL=info             # Logging verbosity
```

## Code Patterns & Best Practices

### Error Handling
- Always wrap database operations in try-catch
- Update job status to 'failed' on errors with error details
- Clean up temporary files even on failure
- Log errors with context (job ID, operation, details)

### File Management
- Use UUIDs for temporary file names to avoid conflicts
- Validate downloaded files before processing
- Stream downloads for large files
- Clean up temp files immediately after use

### Database Operations
- Use atomic updates for job claiming
- Include race condition checks (`WHERE status = 'waiting_render'`)
- Update `updated_at` timestamp on all changes
- Handle concurrent worker scenarios

### FFmpeg Usage
- Use fluent-ffmpeg for Promise-based operations
- Include progress callbacks for long operations
- Set appropriate timeouts for processing
- Use optimal codecs and settings for speed vs quality

## Performance Considerations

### For 4K Video
- Ensure 8GB+ RAM available
- Use SSD storage for temp files
- Monitor CPU usage during processing
- Consider hardware acceleration flags

### For High Throughput  
- Run multiple workers with different temp directories
- Optimize `JOB_CHECK_INTERVAL` based on job frequency
- Monitor database connection limits
- Use separate storage for each worker

## Debugging & Monitoring

### Log Levels
- **ERROR**: Critical failures, job failures
- **WARN**: Important issues, missing resources
- **INFO**: Job progress, completions, worker status
- **DEBUG**: Detailed FFmpeg commands, file operations

### Key Metrics to Monitor
- Job processing time (target: < 30s for 5min video)
- Memory usage during processing
- Disk space in temp/output directories
- Database connection health
- FFmpeg process completion rates

## Troubleshooting Guide

### Common Issues
1. **FFmpeg not found**: Install with `brew install ffmpeg` (macOS)
2. **Memory issues**: Check available RAM, reduce concurrent jobs
3. **Slow processing**: Verify CPU usage, check disk I/O
4. **Database errors**: Check Supabase connection, verify credentials
5. **File download failures**: Check URLs, network connectivity, disk space

### Performance Optimization
- Use `LOG_LEVEL=debug` for detailed diagnostics
- Monitor temp directory size and cleanup
- Check FFmpeg command output for optimization opportunities
- Profile database query performance

## Dependencies

### Core
- `@supabase/supabase-js` - Database client
- `fluent-ffmpeg` - FFmpeg wrapper
- `axios` - HTTP client for downloads
- `fs-extra` - Enhanced file system operations
- `dotenv` - Environment configuration

### Development
- Node.js 18+ (ESM support required)
- FFmpeg installed and in PATH
- Supabase project with database access

## Testing

### Manual Testing
```bash
# Start worker and monitor logs
npm start

# Check output directory for results
ls -la output/
```

### Test Data
- Sample video: Short MP4 files (< 5MB for quick testing)
- Sample audio: WAV files with stereo audio
- Duration: 1-2 minutes for quick turnaround during development

## AI Assistant Guidelines

When helping with this project:

1. **Understand the Context**: This is a production video processing system with performance requirements
2. **Focus on Speed**: Suggest optimizations for parallel processing and FFmpeg efficiency  
3. **Consider Scale**: Solutions should work with multiple concurrent workers
4. **Database Safety**: Always consider race conditions and atomic operations
5. **Error Handling**: Robust error handling is critical for production reliability
6. **Resource Management**: Memory and disk usage are important constraints
7. **Logging**: Include appropriate logging for debugging and monitoring

## Current Status

The system is production-ready with:
- ✅ Supabase integration configured
- ✅ Job queue with race condition protection  
- ✅ Parallel media download and processing
- ✅ Optimized FFmpeg settings for speed and quality
- ✅ Comprehensive error handling and cleanup
- ✅ Structured logging and monitoring

Focus areas for improvement:
- Hardware acceleration optimization
- Batch processing capabilities
- Advanced progress tracking
- Metrics and analytics integration 